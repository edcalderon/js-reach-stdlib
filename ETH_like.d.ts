import real_ethers from 'ethers';
import * as shared from './shared';
import type { BigNumber } from 'ethers';
import type { CurrencyAmount, IAccount, IBackend, IContract } from './shared';
import type { AnyETH_Ty, Token } from './ETH_like_compiled';
import type { EthersLikeSigner, EthersLikeWallet, EthLikeArgs, BackendStdlib } from './ETH_like_interfaces';
declare type DeployMode = 'DM_firstMsg' | 'DM_constructor';
declare type Backend = IBackend<AnyETH_Ty> & {
    _Connectors: {
        ETH: {
            ABI: string;
            Bytecode: string;
            deployMode: DeployMode;
            views: {
                [viewn: string]: {
                    [keyn: string]: string;
                };
            };
        };
    };
};
declare type Address = string;
declare type NetworkAccount = {
    address?: Address;
    getAddress?: () => Promise<Address>;
    sendTransaction?: (...xs: any) => any;
    getBalance?: (...xs: any) => any;
} | EthersLikeWallet | EthersLikeSigner;
declare type Hash = string;
declare type ContractInfo = {
    address: Address;
    creation_block: number;
    transactionHash: Hash;
    init?: ContractInitInfo;
};
declare type Digest = string;
declare type Contract = IContract<ContractInfo, Digest, Address, Token, AnyETH_Ty>;
export declare type Account = IAccount<NetworkAccount, Backend, Contract, ContractInfo> | any;
declare type ContractInitInfo = {
    args: Array<any>;
    value: BigNumber;
};
declare type AccountTransferable = Account | {
    networkAccount: NetworkAccount;
};
export declare function makeEthLike(ethLikeArgs: EthLikeArgs): {
    getFaucet: () => Promise<any>;
    setFaucet: (val: Promise<any>) => void;
    randomUInt: () => real_ethers.ethers.BigNumber;
    hasRandom: {
        random: () => real_ethers.ethers.BigNumber;
    };
    balanceOf: (acc: Account) => Promise<BigNumber>;
    transfer: (from: AccountTransferable, to: AccountTransferable, value: any, token?: Token | false) => Promise<any>;
    connectAccount: (networkAccount: NetworkAccount) => Promise<Account>;
    newAccountFromSecret: (secret: string) => Promise<Account>;
    newAccountFromMnemonic: (phrase: string) => Promise<Account>;
    getDefaultAccount: () => Promise<Account>;
    createAccount: () => Promise<any>;
    fundFromFaucet: (account: AccountTransferable, value: any) => Promise<void>;
    newTestAccount: (startingBalance: any) => Promise<Account>;
    getNetworkTime: () => Promise<BigNumber>;
    wait: (delta: BigNumber, onProgress?: shared.OnProgress | undefined) => Promise<BigNumber>;
    waitUntilTime: (targetTime: BigNumber, onProgress?: shared.OnProgress | undefined) => Promise<BigNumber>;
    verifyContract: (ctcInfo: ContractInfo, backend: Backend) => Promise<true>;
    standardUnit: string;
    atomicUnit: string;
    parseCurrency: (amt: CurrencyAmount) => BigNumber;
    minimumBalance: real_ethers.ethers.BigNumber;
    formatCurrency: (amt: any, decimals?: number) => string;
    formatAddress: (acc: string | NetworkAccount | Account) => string;
    reachStdlib: BackendStdlib;
    getProvider: any;
    setProvider: any;
    setProviderByEnv: any;
    setProviderByName: any;
    providerEnvByName: any;
    stdlib: BackendStdlib;
    typeDefs: import("./ETH_like_interfaces").TypeDefs;
    UInt_max: real_ethers.ethers.BigNumber;
    addressEq: (addr1: unknown, addr2: unknown) => boolean;
    tokenEq: (x: unknown, y: unknown) => boolean;
    digest: (t: AnyETH_Ty, a: unknown) => string;
    bigNumberify: any;
    bigNumberToNumber: any;
    getViewsHelper: any;
    deferContract: any;
    truthyEnv: any;
    envDefault: any;
    setDEBUG: any;
    getDEBUG: any;
    debug: any;
    assert: any;
    isBigNumber: any;
    checkedBigNumberify: any;
    protect: any;
    isHex: any;
    hexToString: any;
    stringToHex: any;
    makeDigest: any;
    hexToBigNumber: any;
    uintToBytes: any;
    bigNumberToHex: any;
    bytesEq: any;
    digestEq: any;
    makeRandom: any;
    eq: any;
    makeArith: any;
    ge: any;
    gt: any;
    le: any;
    lt: any;
    argsSlice: any;
    argsSplit: any;
    Array_set: any;
    Array_zip: any;
    mapRef: any;
    objectMap: any;
    mkAddressEq: any;
    parseFixedPoint: any;
    parseInt: any;
    add: (x: shared.num, y: shared.num) => real_ethers.ethers.BigNumber;
    sub: (x: shared.num, y: shared.num) => real_ethers.ethers.BigNumber;
    mod: (x: shared.num, y: shared.num) => real_ethers.ethers.BigNumber;
    mul: (x: shared.num, y: shared.num) => real_ethers.ethers.BigNumber;
    div: (x: shared.num, y: shared.num) => real_ethers.ethers.BigNumber;
    T_Null: any;
    T_Bool: any;
    T_UInt: any;
    T_Bytes: any;
    T_Address: any;
    T_Digest: any;
    T_Token: any;
    T_Object: any;
    T_Data: any;
    T_Array: any;
    T_Tuple: any;
    T_Struct: any;
};
export {};
//# sourceMappingURL=ETH_like.d.ts.map